#!/usr/bin/env node
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { CallToolRequestSchema, ListToolsRequestSchema, ListResourcesRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { zodToJsonSchema } from "zod-to-json-schema";
import { z } from "zod";
import { ChatTransitionManager, SessionState } from "./context-management/chat-transition.js";
import { SessionStateManager } from "./persistence/session-state.js";
import { FilteredStdioServerTransport } from "./custom-stdio.js";
import * as ProjectPlanning from "./project-planning/index.js";
import * as UIGeneration from "./ui-generation/index.js";
import * as ProjectOrganization from "./project-organization/index.js";
import * as AdvancedFeatures from "./advanced-features/index.js";
import * as Filesystem from "./filesystem/index.js";
import * as Command from "./command/index.js";

// Define schemas for our new tools
const TrackContextSizeSchema = z.object({
  message: z.string(),
});

const TriggerContinuationSchema = z.object({
  state: z.any(),
  summary: z.string(),
});

// Project planning schemas
const GenerateProjectPlanSchema = z.object({
  name: z.string(),
  description: z.string(),
  type: z.enum(['web-application', 'mobile-app', 'api-service', 'desktop-application', 'custom']),
  features: z.array(z.string()),
  timeline: z.object({
    startDate: z.string().optional(),
    endDate: z.string().optional(),
  }).optional(),
  teamSize: z.number().optional(),
  customPhases: z.array(z.string()).optional(),
});

const VisualizeProjectPlanSchema = z.object({
  planId: z.string(),
  format: z.enum(['markdown', 'gantt', 'html']).default('markdown'),
});

const UpdateTaskStatusSchema = z.object({
  planId: z.string(),
  phaseId: z.string(),
  taskId: z.string(),
  status: z.enum(['not-started', 'in-progress', 'completed']),
});


// UI Generation schemas
const GenerateComponentSchema = z.object({
  name: z.string(),
  style: z.enum([
    'basic',
    'card',
    'form',
    'list',
    'table',
    'hero',
    'feature',
    'pricing',
    'cta',
    'footer'
  ]).optional(),
  props: z.array(z.string()).optional(),
  description: z.string().optional(),
});

const GeneratePageSchema = z.object({
  name: z.string(),
  type: z.enum([
    'landing',
    'dashboard',
    'auth',
    'profile',
    'settings',
    'documentation',
    'blog',
    'product',
    'checkout',
    'error'
  ]).optional(),
  sections: z.array(
    z.object({
      type: z.string(),
      name: z.string(),
      props: z.record(z.any()).optional(),
    })
  ).optional(),
  meta: z.object({
    title: z.string().optional(),
    description: z.string().optional(),
    keywords: z.array(z.string()).optional(),
  }).optional(),
});

const GenerateProjectSchema = z.object({
  name: z.string(),
  type: z.enum([
    'landing-page',
    'marketing-site',
    'dashboard',
    'e-commerce',
    'blog',
    'documentation',
    'portfolio',
    'saas'
  ]).optional(),
  framework: z.enum([
    'react-vite',
    'next-js',
    'remix',
    'gatsby'
  ]).optional(),
  styling: z.enum([
    'tailwind',
    'styled-components',
    'emotion',
    'css-modules'
  ]).optional(),
  database: z.enum([
    'supabase',
    'firebase',
    'mongodb',
    'postgresql',
    'mysql',
    'none'
  ]).optional(),
  pages: z.array(
    z.object({
      name: z.string(),
      type: z.string(),
      path: z.string(),
    })
  ).optional(),
});

// Project Organization schemas
const GenerateDirectoryStructureSchema = z.object({
  name: z.string(),
  type: z.enum([
    'web-app',
    'mobile-app',
    'api',
    'library',
    'monorepo',
    'desktop-app',
    'static-site',
    'documentation',
  ]),
  framework: z.enum([
    'react',
    'next-js',
    'vue',
    'angular',
    'express',
    'nest-js',
    'django',
    'flask',
    'spring-boot',
    'laravel',
    'electron',
    'react-native',
    'flutter',
  ]).optional(),
  features: z.array(z.string()).optional(),
});

const GenerateDocumentationSchema = z.object({
  projectName: z.string(),
  projectDescription: z.string(),
  type: z.enum([
    'readme',
    'api-docs',
    'user-guide',
    'developer-guide',
    'contributing',
    'code-of-conduct',
    'changelog',
  ]),
  format: z.enum(['markdown', 'html', 'asciidoc', 'rst']).optional(),
});

const AnalyzeFileSizesSchema = z.object({
  files: z.array(z.object({
    path: z.string(),
    size: z.number(),
    lastModified: z.string().optional(),
  })),
});

// Advanced Features schemas
const TrackVersionChangesSchema = z.object({
  path: z.string(),
  type: z.enum(['add', 'modify', 'delete', 'rename']),
  content: z.string().optional(),
  oldContent: z.string().optional(),
  oldPath: z.string().optional(),
  message: z.string().optional(),
});

const RevertToSnapshotSchema = z.object({
  snapshotId: z.string(),
});

const CreateSnapshotSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  author: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

const GenerateContentSchema = z.object({
  type: z.enum(['legal', 'seo', 'marketing', 'documentation', 'email', 'social']),
  subtype: z.string(),
  company: z.object({
    name: z.string(),
    description: z.string(),
    website: z.string().optional(),
    industry: z.string().optional(),
  }).optional(),
  website: z.object({
    url: z.string(),
    title: z.string(),
    description: z.string(),
    keywords: z.array(z.string()).optional(),
  }).optional(),
  legal: z.object({
    jurisdiction: z.string().optional(),
    effectiveDate: z.string().optional(),
    contactEmail: z.string().optional(),
  }).optional(),
});

const GenerateTranslationsSchema = z.object({
  keys: z.array(z.string()),
  locales: z.array(z.string()),
  baseTranslations: z.record(z.string()).optional(),
});

// Create instances of our managers
const chatTransitionManager = new ChatTransitionManager();
const sessionStateManager = new SessionStateManager();

// Store for project plans
const projectPlans = new Map<string, ProjectPlanning.ProjectPlan>();

// Store for generated UI components
const uiComponents = new Map<string, string>();

// Store for generated UI pages
const uiPages = new Map<string, string>();

// Store for generated UI projects
const uiProjects = new Map<string, UIGeneration.ProjectFile[]>();

// Store for version control state
const versionControlState = AdvancedFeatures.createVersionControlState();

// Store for generated content
const generatedContent = new Map<string, string>();

// Store for translation files
const translationFiles = new Map<string, Record<string, Record<string, string>>>();

// Memory and performance systems have been removed to streamline the app generation process

// Initialize the server
const server = new Server({
  name: "optimuscode",
  version: "0.1.0",
}, {
  capabilities: {
    tools: {},
    resources: {}, 
    prompts: {},
  },
});

// Add handler for resources/list method
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [],
  };
});

// Add handler for tools/list method
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      // Filesystem tools
      {
        name: "read_file",
        description: "Read the complete contents of a file from the file system or a URL. When reading from the file system, only works within allowed directories. Can fetch content from URLs when isUrl parameter is set to true. Handles text files normally and image files are returned as viewable images. Recognized image types: PNG, JPEG, GIF, WebP.",
        inputSchema: zodToJsonSchema(Filesystem.ReadFileArgsSchema),
      },
      {
        name: "read_multiple_files",
        description: "Read the contents of multiple files simultaneously. Each file's content is returned with its path as a reference. Handles text files normally and renders images as viewable content. Recognized image types: PNG, JPEG, GIF, WebP. Failed reads for individual files won't stop the entire operation. Only works within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.ReadMultipleFilesArgsSchema),
      },
      {
        name: "write_file",
        description: "Completely replace file contents. Best for large changes (>20% of file) or when edit_block fails. Use with caution as it will overwrite existing files. Only works within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.WriteFileArgsSchema),
      },
      {
        name: "create_directory",
        description: "Create a new directory or ensure a directory exists. Can create multiple nested directories in one operation. Only works within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.CreateDirectoryArgsSchema),
      },
      {
        name: "list_directory",
        description: "Get a detailed listing of all files and directories in a specified path. Results distinguish between files and directories with [FILE] and [DIR] prefixes. Only works within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.ListDirectoryArgsSchema),
      },
      {
        name: "move_file",
        description: "Move or rename files and directories. Can move files between directories and rename them in a single operation. Both source and destination must be within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.MoveFileArgsSchema),
      },
      {
        name: "get_file_info",
        description: "Retrieve detailed metadata about a file or directory including size, creation time, last modified time, permissions, and type. Only works within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.GetFileInfoArgsSchema),
      },
      {
        name: "search_files",
        description: "Finds files by name using a case-insensitive substring matching. Searches through all subdirectories from the starting path. Has a default timeout of 30 seconds which can be customized using the timeoutMs parameter. Only searches within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.SearchFilesArgsSchema),
      },
      {
        name: "search_code",
        description: "Search for text/code patterns within file contents using ripgrep. Fast and powerful search similar to VS Code search functionality. Supports regular expressions, file pattern filtering, and context lines. Has a default timeout of 30 seconds which can be customized. Only searches within allowed directories.",
        inputSchema: zodToJsonSchema(Filesystem.SearchCodeArgsSchema),
      },
      {
        name: "edit_block",
        description: "Apply surgical text replacements to files. Best for small changes (<20% of file size). Call repeatedly to change multiple blocks. Will verify changes after application. Format: filepath <<<<<<< SEARCH content to find ======= new content >>>>>>> REPLACE",
        inputSchema: zodToJsonSchema(Filesystem.EditBlockArgsSchema),
      },
      
      // Command execution tools
      {
        name: "execute_command",
        description: "Execute a terminal command with timeout. Command will continue running in background if it doesn't complete within timeout.",
        inputSchema: zodToJsonSchema(Command.ExecuteCommandArgsSchema),
      },
      {
        name: "read_output",
        description: "Read new output from a running terminal session.",
        inputSchema: zodToJsonSchema(Command.ReadOutputArgsSchema),
      },
      {
        name: "force_terminate",
        description: "Force terminate a running terminal session.",
        inputSchema: zodToJsonSchema(Command.ForceTerminateArgsSchema),
      },
      {
        name: "list_sessions",
        description: "List all active terminal sessions.",
        inputSchema: zodToJsonSchema(Command.ListSessionsArgsSchema),
      },
      {
        name: "list_processes",
        description: "List all running processes. Returns process information including PID, command name, CPU usage, and memory usage.",
        inputSchema: zodToJsonSchema(Command.ListProcessesArgsSchema),
      },
      {
        name: "kill_process",
        description: "Terminate a running process by PID. Use with caution as this will forcefully terminate the specified process.",
        inputSchema: zodToJsonSchema(Command.KillProcessArgsSchema),
      },
      
      // Context management tools
      {
        name: "track_context_size",
        description: "Track the current context size and determine if a new chat should be created",
        inputSchema: zodToJsonSchema(TrackContextSizeSchema),
      },
      {
        name: "trigger_continuation",
        description: "Trigger a new chat with the current context preserved",
        inputSchema: zodToJsonSchema(TriggerContinuationSchema),
      },
      // Project planning tools
      {
        name: "generate_project_plan",
        description: "Generate a detailed project plan with phases and tasks based on requirements",
        inputSchema: zodToJsonSchema(GenerateProjectPlanSchema),
      },
      {
        name: "visualize_project_plan",
        description: "Visualize a project plan in different formats (markdown, gantt chart, HTML)",
        inputSchema: zodToJsonSchema(VisualizeProjectPlanSchema),
      },
      {
        name: "update_task_status",
        description: "Update the status of a task in a project plan",
        inputSchema: zodToJsonSchema(UpdateTaskStatusSchema),
      },
      // UI Generation tools
      {
        name: "generate_component",
        description: "Generate a UI component with the specified options",
        inputSchema: zodToJsonSchema(GenerateComponentSchema),
      },
      {
        name: "generate_page",
        description: "Generate a UI page with the specified options",
        inputSchema: zodToJsonSchema(GeneratePageSchema),
      },
      {
        name: "generate_project",
        description: "Generate a complete UI project with the specified options",
        inputSchema: zodToJsonSchema(GenerateProjectSchema),
      },
      // Project Organization tools
      {
        name: "generate_directory_structure",
        description: "Generate a directory structure for a project",
        inputSchema: zodToJsonSchema(GenerateDirectoryStructureSchema),
      },
      {
        name: "generate_documentation",
        description: "Generate documentation for a project",
        inputSchema: zodToJsonSchema(GenerateDocumentationSchema),
      },
      {
        name: "analyze_file_sizes",
        description: "Analyze file sizes and suggest optimizations",
        inputSchema: zodToJsonSchema(AnalyzeFileSizesSchema),
      },
      // Advanced Features tools
      // Advanced Features tools
      {
        name: "track_version_changes",
        description: "Track changes to files for version control",
        inputSchema: zodToJsonSchema(TrackVersionChangesSchema),
      },
      {
        name: "create_snapshot",
        description: "Create a snapshot of the current state",
        inputSchema: zodToJsonSchema(CreateSnapshotSchema),
      },
      {
        name: "revert_to_snapshot",
        description: "Revert to a previous snapshot",
        inputSchema: zodToJsonSchema(RevertToSnapshotSchema),
      },
      {
        name: "generate_content",
        description: "Generate content for various purposes",
        inputSchema: zodToJsonSchema(GenerateContentSchema),
      },
      {
        name: "generate_translations",
        description: "Generate translation files for multiple locales",
        inputSchema: zodToJsonSchema(GenerateTranslationsSchema),
      }
    ],
  };
});

// Add handler for tools/call method
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    const { name, arguments: args } = request.params;
    
    switch (name) {
      // Filesystem tools
      case "read_file":
        return await Filesystem.handleReadFile(args);
      case "read_multiple_files":
        return await Filesystem.handleReadMultipleFiles(args);
      case "write_file":
        return await Filesystem.handleWriteFile(args);
      case "create_directory":
        return await Filesystem.handleCreateDirectory(args);
      case "list_directory":
        return await Filesystem.handleListDirectory(args);
      case "move_file":
        return await Filesystem.handleMoveFile(args);
      case "get_file_info":
        return await Filesystem.handleGetFileInfo(args);
      case "search_files":
        return await Filesystem.handleSearchFiles(args);
      case "search_code":
        return await Filesystem.handleSearchCode(args);
      case "edit_block":
        return await Filesystem.handleEditBlock(args);
        
      // Command execution tools
      case "execute_command":
        return await Command.handleExecuteCommand(args);
      case "read_output":
        return await Command.handleReadOutput(args);
      case "force_terminate":
        return await Command.handleForceTerminate(args);
      case "list_sessions":
        return await Command.handleListSessions();
      case "list_processes":
        return await Command.handleListProcesses();
      case "kill_process":
        return await Command.handleKillProcess(args);
        
      // Context management tools
      case "track_context_size":
        if (args && typeof args === 'object' && 'message' in args && typeof args.message === 'string') {
          chatTransitionManager.trackMessage(args.message);
          return {
            content: [{
              type: "text",
              text: `Context size tracked. Current token count: ${chatTransitionManager.getTokenCount()}. Should transition: ${chatTransitionManager.shouldCreateNewChat()}`
            }],
          };
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for track_context_size" }],
          isError: true,
        };
        
      case "trigger_continuation":
        if (args && typeof args === 'object' && 'state' in args && 'summary' in args && typeof args.summary === 'string') {
          const state: SessionState = {
            projectState: args.state,
            activeFiles: [],
            activeSessions: [],
            currentTask: args.summary,
            contextSummary: args.summary
          };
          
          // Generate a unique session ID
          const sessionId = `session-${Date.now()}`;
          
          // Save the state
          await sessionStateManager.initialize();
          await sessionStateManager.saveState(sessionId, state);
          
          return {
            content: [{
              type: "text",
              text: chatTransitionManager.createTransitionMessage(state) + `\nSession ID: ${sessionId}`
            }],
          };
        }
        
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for trigger_continuation" }],
          isError: true,
        };
        
      case "generate_project_plan":
        if (args && typeof args === 'object') {
          try {
            // Create the requirements object with type assertions
            const requirements: ProjectPlanning.ProjectRequirements = {
              name: String(args.name),
              description: String(args.description),
              type: args.type as ProjectPlanning.ProjectType,
              features: Array.isArray(args.features) ? args.features.map(String) : [],
              teamSize: typeof args.teamSize === 'number' ? args.teamSize : undefined,
              customPhases: Array.isArray(args.customPhases) ? args.customPhases.map(String) : undefined,
            };
            
            // Handle timeline separately
            if (args.timeline && typeof args.timeline === 'object') {
              const timeline: { startDate?: Date; endDate?: Date } = {};
              
              // Use type assertion with any to bypass TypeScript's type checking
              const timelineObj = args.timeline as any;
              
              if (timelineObj.startDate && typeof timelineObj.startDate === 'string') {
                timeline.startDate = new Date(timelineObj.startDate);
              }
              
              if (timelineObj.endDate && typeof timelineObj.endDate === 'string') {
                timeline.endDate = new Date(timelineObj.endDate);
              }
              
              if (timeline.startDate || timeline.endDate) {
                requirements.timeline = timeline;
              }
            }
            
            // Generate the project plan
            const plan = ProjectPlanning.generateProjectPlan(requirements);
            
            // Store the plan
            projectPlans.set(plan.id, plan);
            
            // Generate markdown representation
            const markdown = ProjectPlanning.renderAsMarkdown(plan);
            
            return {
              content: [
                {
                  type: "text",
                  text: `Project plan generated successfully with ID: ${plan.id}\n\n${markdown}`
                }
              ],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating project plan: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_project_plan" }],
          isError: true,
        };
        
      case "visualize_project_plan":
        if (args && typeof args === 'object' && 'planId' in args) {
          const planId = args.planId as string;
          const format = args.format as 'markdown' | 'gantt' | 'html' || 'markdown';
          
          // Get the plan
          const plan = projectPlans.get(planId);
          if (!plan) {
            return {
              content: [{ type: "text", text: `Error: Project plan with ID ${planId} not found` }],
              isError: true,
            };
          }
          
          // Visualize the plan
          let visualization = '';
          switch (format) {
            case 'gantt':
              visualization = ProjectPlanning.renderAsGanttChart(plan);
              break;
            case 'html':
              visualization = ProjectPlanning.renderAsHTML(plan);
              break;
            case 'markdown':
            default:
              visualization = ProjectPlanning.renderAsMarkdown(plan);
              break;
          }
          
          return {
            content: [{ type: "text", text: visualization }],
          };
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for visualize_project_plan" }],
          isError: true,
        };
        
      case "update_task_status":
        if (args && typeof args === 'object' && 'planId' in args && 'phaseId' in args && 'taskId' in args && 'status' in args) {
          const planId = args.planId as string;
          let phaseId = args.phaseId as string;
          let taskId = args.taskId as string;
          const status = args.status as 'not-started' | 'in-progress' | 'completed';
          
          // Get the plan
          const plan = projectPlans.get(planId);
          if (!plan) {
            return {
              content: [{ type: "text", text: `Error: Project plan with ID ${planId} not found` }],
              isError: true,
            };
          }
          
          try {
            // Handle different phase ID formats
            // Convert formats like "phase_1" or "Planning" to "phase-1"
            let phaseIndex = -1;
            
            // Try exact match first
            phaseIndex = plan.phases.findIndex(phase => phase.id === phaseId);
            
            // Try by phase number (phase_1 -> phase-1)
            if (phaseIndex === -1 && phaseId.includes('_')) {
              const phaseNumber = phaseId.split('_').pop();
              if (phaseNumber) {
                const alternativeId = `phase-${phaseNumber}`;
                phaseIndex = plan.phases.findIndex(phase => phase.id === alternativeId);
                if (phaseIndex !== -1) {
                  phaseId = alternativeId;
                }
              }
            }
            
            // Try by phase name
            if (phaseIndex === -1) {
              phaseIndex = plan.phases.findIndex(phase =>
                phase.name.toLowerCase() === phaseId.toLowerCase() ||
                phase.name.toLowerCase().replace(/\s+/g, '-') === phaseId.toLowerCase()
              );
              if (phaseIndex !== -1) {
                phaseId = plan.phases[phaseIndex].id;
              }
            }
            
            // Try by index (1 -> phase-1)
            if (phaseIndex === -1 && /^\d+$/.test(phaseId)) {
              const index = parseInt(phaseId) - 1;
              if (index >= 0 && index < plan.phases.length) {
                phaseIndex = index;
                phaseId = plan.phases[index].id;
              }
            }
            
            if (phaseIndex === -1) {
              // If we still can't find the phase, list available phases
              const availablePhases = plan.phases.map(phase =>
                `${phase.id} (${phase.name})`
              ).join(', ');
              
              return {
                content: [{
                  type: "text",
                  text: `Error: Phase with ID "${phaseId}" not found. Available phases: ${availablePhases}`
                }],
                isError: true,
              };
            }
            
            // Handle different task ID formats
            // Convert formats like "task_phase_1_1" to "task-phase-1-1"
            let taskIndex = -1;
            const phase = plan.phases[phaseIndex];
            
            // Try exact match first
            taskIndex = phase.tasks.findIndex(task => task.id === taskId);
            
            // Try by task name
            if (taskIndex === -1) {
              taskIndex = phase.tasks.findIndex(task =>
                task.name.toLowerCase() === taskId.toLowerCase() ||
                task.name.toLowerCase().replace(/\s+/g, '-') === taskId.toLowerCase()
              );
              if (taskIndex !== -1) {
                taskId = phase.tasks[taskIndex].id;
              }
            }
            
            // Try by index (1 -> first task in phase)
            if (taskIndex === -1 && /^\d+$/.test(taskId)) {
              const index = parseInt(taskId) - 1;
              if (index >= 0 && index < phase.tasks.length) {
                taskIndex = index;
                taskId = phase.tasks[index].id;
              }
            }
            
            if (taskIndex === -1) {
              // If we still can't find the task, list available tasks
              const availableTasks = phase.tasks.map(task =>
                `${task.id} (${task.name})`
              ).join(', ');
              
              return {
                content: [{
                  type: "text",
                  text: `Error: Task with ID "${taskId}" not found in phase "${phase.name}". Available tasks: ${availableTasks}`
                }],
                isError: true,
              };
            }
            
            // Update the task status
            const updatedPlan = ProjectPlanning.updateTaskStatus(plan, phaseId, taskId, status);
            
            // Store the updated plan
            projectPlans.set(planId, updatedPlan);
            
            // Calculate progress
            const progress = ProjectPlanning.calculateProgress(updatedPlan);
            const progressPercentage = Math.round(progress * 100);
            
            return {
              content: [{
                type: "text",
                text: `Task "${phase.tasks[taskIndex].name}" status updated to "${status}". Overall project progress: ${progressPercentage}%`
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error updating task status: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for update_task_status" }],
          isError: true,
        };
        
        
        
      case "generate_component":
        if (args && typeof args === 'object' && 'name' in args) {
          const name = args.name as string;
          const style = args.style as UIGeneration.ComponentStyle || UIGeneration.ComponentStyle.BASIC;
          const props = args.props as string[] || [];
          const description = args.description as string || `${name} component`;
          
          try {
            // Generate the component
            const componentCode = UIGeneration.generateReactComponent(
              name,
              style,
              props,
              description
            );
            
            // Store the component
            const componentId = `component-${Date.now()}`;
            uiComponents.set(componentId, componentCode);
            
            return {
              content: [{
                type: "text",
                text: `Component generated successfully with ID: ${componentId}\n\n\`\`\`tsx\n${componentCode}\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating component: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_component" }],
          isError: true,
        };
        
      case "generate_page":
        if (args && typeof args === 'object' && 'name' in args) {
          const name = args.name as string;
          const type = args.type as UIGeneration.PageType || UIGeneration.PageType.LANDING;
          const sections = args.sections as UIGeneration.PageSection[] || UIGeneration.DEFAULT_LANDING_PAGE_SECTIONS;
          const meta = args.meta as { title?: string; description?: string; keywords?: string[] } || {};
          
          try {
            // Generate the page
            const pageOptions: UIGeneration.PageOptions = {
              name,
              type,
              sections,
              meta,
              withNavbar: true,
              withFooter: true,
              withDarkMode: true,
            };
            
            const pageCode = UIGeneration.generatePage(pageOptions);
            
            // Store the page
            const pageId = `page-${Date.now()}`;
            uiPages.set(pageId, pageCode);
            
            return {
              content: [{
                type: "text",
                text: `Page generated successfully with ID: ${pageId}\n\n\`\`\`tsx\n${pageCode.substring(0, 1000)}...\n\nFull page code is ${pageCode.length} characters long.\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating page: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_page" }],
          isError: true,
        };
        
      case "generate_project":
        if (args && typeof args === 'object' && 'name' in args) {
          const name = args.name as string;
          const type = args.type as UIGeneration.ProjectType || UIGeneration.ProjectType.LANDING_PAGE;
          const framework = args.framework as UIGeneration.ProjectFramework || UIGeneration.ProjectFramework.REACT_VITE;
          const styling = args.styling as UIGeneration.ProjectStyling || UIGeneration.ProjectStyling.TAILWIND;
          const database = args.database as UIGeneration.ProjectDatabase || UIGeneration.ProjectDatabase.SUPABASE;
          const pages = args.pages as { name: string; type: string; path: string }[] || [
            { name: 'Home', type: 'landing', path: 'pages/Home.tsx' },
          ];
          
          try {
            // Generate the project
            const projectOptions: UIGeneration.ProjectOptions = {
              name,
              type,
              framework,
              styling,
              database,
              authentication: UIGeneration.ProjectAuthentication.SUPABASE,
              pages: pages.map(page => ({
                name: page.name,
                type: page.type as UIGeneration.PageType,
                path: page.path,
              })),
              components: [],
            };
            
            const projectFiles = UIGeneration.generateProject(projectOptions);
            
            // Store the project
            const projectId = `project-${Date.now()}`;
            uiProjects.set(projectId, projectFiles);
            
            // Generate a summary of the project files
            const filesSummary = projectFiles.map(file => `- ${file.path}`).join('\n');
            
            return {
              content: [{
                type: "text",
                text: `Project generated successfully with ID: ${projectId}\n\nProject contains ${projectFiles.length} files:\n${filesSummary}\n\nExample file (${projectFiles[0].path}):\n\n\`\`\`\n${projectFiles[0].content.substring(0, 500)}...\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating project: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_project" }],
          isError: true,
        };
        
      case "generate_directory_structure":
        if (args && typeof args === 'object' && 'name' in args && 'type' in args) {
          const name = args.name as string;
          const type = args.type as ProjectOrganization.ProjectType;
          const framework = args.framework as ProjectOrganization.ProjectFramework | undefined;
          const features = args.features as string[] || [];
          
          try {
            // Generate the directory structure
            const options: ProjectOrganization.DirectoryStructureOptions = {
              name,
              type,
              framework,
              features,
            };
            
            const structure = ProjectOrganization.generateDirectoryStructure(options);
            
            // Generate markdown representation
            const markdown = ProjectOrganization.directoryStructureToMarkdown(structure);
            
            return {
              content: [{
                type: "text",
                text: `Directory structure generated for ${name}:\n\n\`\`\`\n${markdown}\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating directory structure: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_directory_structure" }],
          isError: true,
        };
        
      case "generate_documentation":
        if (args && typeof args === 'object' && 'projectName' in args && 'projectDescription' in args && 'type' in args) {
          const projectName = args.projectName as string;
          const projectDescription = args.projectDescription as string;
          const type = args.type as ProjectOrganization.DocumentationType;
          const format = args.format as ProjectOrganization.DocumentationFormat || ProjectOrganization.DocumentationFormat.MARKDOWN;
          
          try {
            // Generate the documentation
            const options: ProjectOrganization.DocumentationOptions = {
              projectName,
              projectDescription,
              type,
              format,
            };
            
            const documentation = ProjectOrganization.generateDocumentation(options);
            
            return {
              content: [{
                type: "text",
                text: `Documentation generated for ${projectName}:\n\n\`\`\`\n${documentation}\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating documentation: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_documentation" }],
          isError: true,
        };
        
      case "analyze_file_sizes":
        if (args && typeof args === 'object' && 'files' in args && Array.isArray(args.files)) {
          const files = args.files as { path: string; size: number; lastModified?: string }[];
          
          try {
            // Convert lastModified strings to Date objects
            const filesWithDates = files.map(file => ({
              ...file,
              lastModified: file.lastModified ? new Date(file.lastModified) : undefined,
            }));
            
            // Analyze file sizes
            const report = ProjectOrganization.analyzeFileSizes(filesWithDates);
            
            // Generate report
            const reportMarkdown = ProjectOrganization.generateFileSizeReport(report);
            
            return {
              content: [{
                type: "text",
                text: reportMarkdown
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error analyzing file sizes: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for analyze_file_sizes" }],
          isError: true,
        };

      // Memory system handlers
      case "get_user_preferences":
        if (!memorySystem) {
          return {
            content: [{ type: "text", text: "Memory system not initialized" }],
            isError: true,
          };
        }
        
        const userProfile = memorySystem.profileManager.getCurrentProfile();
        if (!userProfile) {
          return {
            content: [{ type: "text", text: "No user profile loaded" }],
            isError: true,
          };
        }
        
        return {
          content: [{
            type: "text",
            text: `Current User Preferences:\n\n\`\`\`json\n${JSON.stringify(userProfile.preferences, null, 2)}\n\`\`\``
          }],
        };
        
      case "update_user_preferences":
        if (!memorySystem) {
          return {
            content: [{ type: "text", text: "Memory system not initialized" }],
            isError: true,
          };
        }
        
        if (args && typeof args === 'object' && 'preferences' in args) {
          const preferences = args.preferences as Record<string, any>;
          
          try {
            // Convert the preferences to the expected format
            const partialPreferences: {
              coding?: Partial<Memory.CodingPreferences>;
              ui?: Partial<Memory.UIPreferences>;
              tools?: Partial<Memory.ToolPreferences>;
              language?: Partial<Memory.LanguagePreferences>;
            } = {};
            
            if ('coding' in preferences) {
              partialPreferences.coding = preferences.coding;
            }
            
            if ('ui' in preferences) {
              partialPreferences.ui = preferences.ui;
            }
            
            if ('tools' in preferences) {
              partialPreferences.tools = preferences.tools;
            }
            
            if ('language' in preferences) {
              partialPreferences.language = preferences.language;
            }
            
            // Update the preferences
            const updatedProfile = await memorySystem.profileManager.updatePartialPreferences(partialPreferences);
            
            if (!updatedProfile) {
              return {
                content: [{ type: "text", text: "Failed to update preferences" }],
                isError: true,
              };
            }
            
            return {
              content: [{
                type: "text",
                text: `Preferences updated successfully:\n\n\`\`\`json\n${JSON.stringify(updatedProfile.preferences, null, 2)}\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error updating preferences: ${error}` }],
              isError: true,
            };
          }
        }
        
      case "track_version_changes":
        if (args && typeof args === 'object' && 'path' in args && 'type' in args) {
          const path = args.path as string;
          const type = args.type as AdvancedFeatures.ChangeType;
          const content = args.content as string | undefined;
          const oldContent = args.oldContent as string | undefined;
          const oldPath = args.oldPath as string | undefined;
          const message = args.message as string | undefined;
          
          try {
            // Record the change
            const newState = AdvancedFeatures.recordChange(versionControlState, {
              path,
              type,
              content,
              oldContent,
              oldPath,
              message,
            });
            
            // Update the state
            Object.assign(versionControlState, newState);
            
            // Generate a diff if applicable
            let diffText = '';
            if (type === AdvancedFeatures.ChangeType.MODIFY && content && oldContent) {
              diffText = `\n\nDiff:\n\`\`\`diff\n${AdvancedFeatures.generateDiff(oldContent, content)}\n\`\`\``;
            }
            
            return {
              content: [{
                type: "text",
                text: `Change recorded for ${path}. Total pending changes: ${versionControlState.changes.length}.${diffText}`
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error tracking version changes: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for track_version_changes" }],
          isError: true,
        };

          return {
            content: [{ type: "text", text: "No user profile loaded" }],
            isError: true,
          };
        }
        
      case "create_snapshot":
        if (args && typeof args === 'object' && 'name' in args) {
          const name = args.name as string;
          const description = args.description as string | undefined;
          const author = args.author as string | undefined;
          const tags = args.tags as string[] | undefined;
          
          try {
            // Create a snapshot
            const newState = AdvancedFeatures.createSnapshot(
              versionControlState,
              name,
              description,
              author,
              tags
            );
            
            // Update the state
            Object.assign(versionControlState, newState);
            
            return {
              content: [{
                type: "text",
                text: `Snapshot "${name}" created with ID: ${versionControlState.currentSnapshot}. ${versionControlState.changes.length} pending changes have been committed.`
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error creating snapshot: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for create_snapshot" }],
          isError: true,
        };
        
      case "revert_to_snapshot":
        if (args && typeof args === 'object' && 'snapshotId' in args) {
          const snapshotId = args.snapshotId as string;
          
          try {
            // Find the snapshot
            const snapshot = versionControlState.snapshots.find(s => s.id === snapshotId);
            
            if (!snapshot) {
              // If snapshot ID not found, list available snapshots
              const availableSnapshots = versionControlState.snapshots.map(s =>
                `${s.id} (${s.name})`
              ).join('\n');
              
              return {
                content: [{
                  type: "text",
                  text: `Snapshot with ID ${snapshotId} not found. Available snapshots:\n${availableSnapshots}`
                }],
                isError: true,
              };
            }
            
            // Revert to the snapshot
            const newState = AdvancedFeatures.revertToSnapshot(
              versionControlState,
              snapshotId
            );
            
            // Update the state
            Object.assign(versionControlState, newState);
            
            return {
              content: [{
                type: "text",
                text: `Reverted to snapshot "${snapshot.name}" (${snapshotId}). Any pending changes have been discarded.`
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error reverting to snapshot: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for revert_to_snapshot" }],
          isError: true,
        };
        
      case "generate_content":
        if (args && typeof args === 'object' && 'type' in args && 'subtype' in args) {
          const type = args.type as AdvancedFeatures.ContentType;
          const subtype = args.subtype as string;
          const company = args.company as AdvancedFeatures.ContentOptions['company'] | undefined;
          const website = args.website as AdvancedFeatures.ContentOptions['website'] | undefined;
          const legal = args.legal as AdvancedFeatures.ContentOptions['legal'] | undefined;
          
          try {
            // Generate the content
            const options: AdvancedFeatures.ContentOptions = {
              type,
              subtype,
              company,
              website,
              legal,
            };
            
            let content = '';
            if (type === AdvancedFeatures.ContentType.LEGAL) {
              content = AdvancedFeatures.generateLegalContent(options);
            } else if (type === AdvancedFeatures.ContentType.SEO) {
              content = AdvancedFeatures.generateSeoContent(options);
            } else {
              throw new Error(`Content type ${type} not supported yet`);
            }
            
            // Store the content
            const contentId = `content-${Date.now()}`;
            generatedContent.set(contentId, content);
            
            return {
              content: [{
                type: "text",
                text: `Content generated successfully with ID: ${contentId}\n\n\`\`\`\n${content}\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating content: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_content" }],
          isError: true,
        };
        
      case "generate_translations":
        if (args && typeof args === 'object' && 'keys' in args && 'locales' in args) {
          const keys = args.keys as string[];
          const locales = args.locales as string[];
          const baseTranslations = args.baseTranslations as Record<string, string> | undefined;
          
          try {
            // Generate the translations
            const translations = AdvancedFeatures.generateTranslationFiles(
              keys,
              locales,
              baseTranslations
            );
            
            // Store the translations
            const translationId = `translations-${Date.now()}`;
            translationFiles.set(translationId, translations);
            
            // Generate a preview
            const preview = Object.entries(translations).map(([locale, translations]) => {
              return `${locale}:\n${Object.entries(translations).map(([key, value]) => `  "${key}": "${value}"`).join('\n')}`;
            }).join('\n\n');
            
            return {
              content: [{
                type: "text",
                text: `Translations generated successfully with ID: ${translationId}\n\nPreview:\n\`\`\`\n${preview}\n\`\`\``
              }],
            };
          } catch (error) {
            return {
              content: [{ type: "text", text: `Error generating translations: ${error}` }],
              isError: true,
            };
          }
        }
        return {
          content: [{ type: "text", text: "Error: Invalid arguments for generate_translations" }],
          isError: true,
        };

        
      
      default:
        return {
          content: [{ type: "text", text: `Error: Unknown tool: ${name}` }],
          isError: true,
        };
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      content: [{ type: "text", text: `Error: ${errorMessage}` }],
      isError: true,
    };
  }
});

// Main function to run the server
async function runServer() {
  try {
    console.error("Initializing OptimusCode MCP server...");
    
    // Initialize the session state manager
    await sessionStateManager.initialize();
    
    // Use our custom FilteredStdioServerTransport
    const transport = new FilteredStdioServerTransport();
    
    console.error("Connecting server...");
    await server.connect(transport);
    console.error("Server connected successfully");
  } catch (error) {
    console.error(`FATAL ERROR: ${error}`);
    process.exit(1);
  }
}

// Run the server
runServer().catch((error) => {
  console.error(`RUNTIME ERROR: ${error}`);
  process.exit(1);
});